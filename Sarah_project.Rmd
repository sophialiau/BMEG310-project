---
title: "Sarah"
author: "Sarah Dumont"
date: "2025-11-25"
output: html_document
---


```{r setup, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(dplyr)
library(readr)
library(tibble)
library(ggplot2)

# --- Load Data ---
clinical <- read_tsv(
  "data_clinical_patient.txt",
  comment = "#",
  show_col_types = FALSE
)

mutation <- read.delim(
  "data_mutations.txt",
  sep = "\t",
  header = TRUE,
  stringsAsFactors = FALSE
)

# --- Helper: normalize TCGA IDs to first 12 chars with dashes ---
normalize_tcga <- function(x) {
  x <- as.character(x)
  x <- gsub("\\.", "-", x)
  substr(x, 1, 12)
}

# --- Get patient IDs in clinical and mutation data ---
clin_ids <- unique(normalize_tcga(clinical$PATIENT_ID))
mut_ids  <- unique(normalize_tcga(mutation$Tumor_Sample_Barcode))

# Only keep patients that are in BOTH clinical and mutation datasets
common_ids <- intersect(clin_ids, mut_ids)

# --- Filter clinical to common patients (not actually used below, but kept for completeness) ---
clinical <- clinical %>%
  mutate(PATIENT_ID = normalize_tcga(PATIENT_ID)) %>%
  filter(PATIENT_ID %in% common_ids)

# --- Filter to NON-SYNONYMOUS mutations (single clean list) ---
nonsynonymous <- c(
  "Missense_Mutation", "Nonsense_Mutation",
  "Nonstop_Mutation",
  "Frame_Shift_Del", "Frame_Shift_Ins",
  "In_Frame_Del", "In_Frame_Ins",
  "Splice_Site", "Translation_Start_Site"
)

mutation_ns <- mutation %>%
  mutate(PATIENT_ID = normalize_tcga(Tumor_Sample_Barcode)) %>%
  filter(
    Variant_Classification %in% nonsynonymous,
    PATIENT_ID %in% common_ids
  )

# --- Build Gene × Patient mutation matrix (0/1) ---
genes    <- sort(unique(mutation_ns$Hugo_Symbol))
patients <- sort(unique(mutation_ns$PATIENT_ID))

mut_matrix <- matrix(
  0L,
  nrow = length(genes),
  ncol = length(patients),
  dimnames = list(genes, patients)
)

for (i in seq_len(nrow(mutation_ns))) {
  g <- mutation_ns$Hugo_Symbol[i]
  p <- mutation_ns$PATIENT_ID[i]
  mut_matrix[g, p] <- 1L
}

# --- Gene mutation frequencies across the cohort ---
gene_freq <- rowSums(mut_matrix)  # how many patients mutated per gene

top_n <- 20  # change this if you want more/less
top_genes <- sort(gene_freq, decreasing = TRUE)[1:top_n]

top_genes_df <- tibble(
  Gene = names(top_genes),
  Mutated_Patients = as.integer(top_genes)
)



```


```{r}
# --- Bar plot of most frequently mutated genes ---
ggplot(top_genes_df,
       aes(x = reorder(Gene, Mutated_Patients),
           y = Mutated_Patients)) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  theme_minimal(base_size = 14) +
  labs(
    title = paste("Top", top_n, "Most Frequently Mutated Genes"),
    x = "Gene",
    y = "Number of Patients with a Non-synonymous Mutation"
  )
```

```{r}
# --- Histogram of Mutation Counts per Gene ---

# mutation count for each gene
gene_mut_counts <- rowSums(mut_matrix)

# put into a data frame
gene_freq_df <- data.frame(
  Gene = names(gene_mut_counts),
  Count = as.numeric(gene_mut_counts)
)

# histogram
ggplot(gene_freq_df, aes(x = Count)) +
  geom_histogram(
    bins = 50,
    fill = "steelblue",
    color = "black",
    alpha = 0.7
  ) +
  theme_minimal(base_size = 14) +
  labs(
    title = "Distribution of Mutation Frequencies Across Genes",
    x = "Number of Patients Mutated (per gene)",
    y = "Number of Genes"
  )

```

```{r}
# Number of mutated genes per patient
patient_mut_counts <- colSums(mut_matrix)

# Mean TMB (mean mutated genes)
mean_mutated_genes <- mean(patient_mut_counts)

mean_mutated_genes

```
```{r}
# Gene variance across patients (binary 0/1)
gene_variance <- apply(mut_matrix, 1, var)

# Sort descending
gene_variance_sorted <- sort(gene_variance, decreasing = TRUE)

# Look at the top variance genes
head(gene_variance_sorted, 20)

```

```{r}

# 1. Gene variance across patients
gene_variance <- apply(mut_matrix, 1, var)

# 2. Sort by variance (high → low)
gene_variance_sorted <- sort(gene_variance, decreasing = TRUE)

# 3. Basic variance curve (log scale)
plot(
  gene_variance_sorted,
  type = "l",
  log = "y",
  lwd = 2,
  col = "blue",
  xlab = "Gene Rank (sorted by variance)",
  ylab = "Variance (log scale)",
  main = "Gene Variance Distribution with Elbow"
)

# 4. Approximate elbow via second derivative on log-variance
y_log <- log10(gene_variance_sorted + 1e-10)  # avoid log(0)
d1 <- diff(y_log)
d2 <- diff(d1)

# We look for the point of **maximum curvature**
elbow <- which.max(-d2) + 1   # +1 to align with original index

elbow

# 5. Add vertical line at elbow
abline(v = elbow, col = "red", lwd = 2, lty = 2)

text(
  x = elbow,
  y = max(gene_variance_sorted),
  labels = paste("Elbow =", elbow),
  pos = 4,
  col = "red"
)

# 6. Extract "significant" genes (above elbow)
significant_genes <- names(gene_variance_sorted)[1:elbow]
head(significant_genes)
length(significant_genes)



```

✔ A small group of genes drive almost all variation
✔ Most genes in the genome are not mutated in this cancer type
✔ The “important” high-variance genes are the ones involved in the disease

Top 6 most frequelntly mutated genes "TP53"   "TTN"    "CTNNB1" "MUC16"  "ALB"    "PCLO" 



```{r}
# --- PCA to Assess Variance Structure ---

# 1. Transpose mut_matrix → rows = patients, cols = genes
X <- t(mut_matrix)

# 2. PCA (center & scale recommended for binary mutation data)
pca_res <- prcomp(X, center = TRUE, scale. = TRUE)

# 3. Variance explained per PC
var_explained <- pca_res$sdev^2 / sum(pca_res$sdev^2)

# 4. Cumulative variance explained
cum_var <- cumsum(var_explained)

# 5. Find how many PCs needed for 90% variance
num_pcs_90 <- which(cum_var >= 0.99)[1]

num_pcs_90

```

I ran PCA here to understand why we don't want to be using PCA! 270 PCAs is alot typically when doing PCA analysis we end up / want to end up with less then 10 PCAs, however here the reason that we have so many is because there is so many genes and some of them only have a couple mutations means that this will have low variance but becasue so many of them have low varianvce PCA needs alot more PCAs to achive 90 percent


```{r}
length(genes)
```
```{r}
gene_variance <- apply(mut_matrix, 1, var)
sort(gene_variance, decreasing = TRUE)[1:20]

```

Look into 




Question 1: 



Question 2: can a model be predicted that can accuratly determine the stage of cancer.

```{r}
# --- Find and collapse cancer stage into 1–4 ---
stage_col <- "AJCC_PATHOLOGIC_TUMOR_STAGE"

stage_col <- stage_candidates[1]     # use first match
stage_col                             # prints the chosen column

# 2) Function to clean stage strings
clean_stage_to_14 <- function(x) {
  x <- toupper(as.character(x))
  x <- gsub("^STAGE\\s*", "", x)   # remove "Stage "
  x <- gsub("[A]+$", "", x)      # remove letters A/B/C/etc.
  x <- trimws(x)

  dplyr::case_when(
    x %in% c("I", "1")   ~ 1L,
    x %in% c("II", "2")  ~ 2L,
    x %in% c("III", "3") ~ 3L,
    x %in% c("IV", "4")  ~ 4L,
    TRUE ~ NA_integer_
  )
}

# 3) Apply stage collapse
clinical_stage <- clinical %>%
  mutate(
    Stage_raw = .data[[stage_col]],
    Stage_num = clean_stage_to_14(Stage_raw),
    Stage_grp = factor(
      Stage_num,
      levels = 1:4,
      labels = paste("Stage", 1:4)
    )
  ) %>%
  filter(!is.na(Stage_num)) %>%
  select(PATIENT_ID, Stage_raw, Stage_num, Stage_grp)

clinical_stage


```


```{r}


tmb_stage <- tmb_df %>%
  inner_join(clinical_stage, by = "PATIENT_ID")

ggplot(tmb_stage, aes(x = Stage_grp, y = TMB)) +
  geom_boxplot(fill = "lightblue", alpha = 0.5) +
  geom_jitter(width = 0.2, alpha = 0.6) +
  theme_minimal(base_size = 14) +
  labs(
    title = "Tumor Mutation Burden by Collapsed Stage (I–IV)",
    x = "Stage (Grouped)",
    y = "TMB (Non-synonymous Mutations)"
  )

```
Look into the TMB to see if maybe total number of mutations could be an indicator of stage of cancer. From this box plot it looks like most are in similar ranges meaning purely quantity of mutated genes is not a good indicator. So further analysis on specifc mutated genes would potenitally be a better indicator of cancer stage be a better indicator


TMB alone is not a good staging biomarker
These box plots do not have enough variation a model will not be able to distiguish these catigoeies   


```{r}
# Count patients per collapsed stage
table(clinical_stage$Stage_grp)

# Or a nicer data frame
stage_counts <- clinical_stage %>%
  count(Stage_grp)

stage_counts

```
Troubles: cannot do with by simply splitting stages because stage for only has 4 patients so we will combine into early and late stage cancer instead.






```{r}

# Cobine into Early Stage and Late Stage
clinical_stage <- clinical_stage %>%
  mutate(
    Stage_binary_2 = case_when(
      Stage_num %in% c(1, 2) ~ "Early Stages",
      Stage_num %in% c(3, 4) ~ "Late Stages",
      TRUE ~ NA_character_
    ),
    Stage_binary_2 = factor(
      Stage_binary_2,
      levels = c("Early Stages", "Late Stages")
    )
  )

```


```{r}
gene_freq <- rowSums(mut_matrix)
top_genes <- names(sort(gene_freq, decreasing = TRUE))[1:50] # look at top 50 mutated genes
top_genes

# Build patient × gene table
gene_df <- t(mut_matrix[top_genes, ]) %>%
  as.data.frame() %>%
  mutate(PATIENT_ID = rownames(.)) %>%
  inner_join(clinical_stage, by = "PATIENT_ID")

# Calculate mutation proportion per stage
stage_gene_freq <- gene_df %>%
  group_by(Stage_binary_2) %>%
  summarise(across(top_genes, mean))

stage_gene_freq
#write.table(stage_gene_freq, row.names = FALSE, sep = ",")
```


```{r}

# Get just the gene columns (everything except Stage_binary_2)
genes <- setdiff(names(stage_gene_freq), "Stage_binary_2")

# Extract rows for Early and Late
early_row <- stage_gene_freq %>%
  filter(Stage_binary_2 == "Early Stages") %>%
  select(all_of(genes))

late_row <- stage_gene_freq %>%
  filter(Stage_binary_2 == "Late Stages") %>%
  select(all_of(genes))

# Compute Late - Early for each gene
diff_vec <- as.numeric(late_row[1, ] - early_row[1, ])

# Build a table: gene, difference, absolute difference
gene_diff_tbl <- tibble(
  Gene     = genes,
  Diff     = diff_vec,           # Late - Early (signed)
  Abs_Diff = abs(diff_vec)       # absolute difference
) %>%
  arrange(desc(Abs_Diff))         # sort by largest absolute difference

gene_diff_tbl <- gene_diff_tbl[1:10, ]

# If you want an easy copy/paste version:
write.table(gene_diff_tbl, row.names = FALSE, sep = ",")

```


```{r}
library(dplyr)

# --- Your top-10 most different genes (already sorted by Abs_Diff) ---
gene_diff_tbl <- tibble::tribble(
  ~Gene,     ~Diff,         ~Abs_Diff,
  "FAT3",    0.0718912666,  0.0718912666,
  "DNAH6",  -0.0647773279,  0.0647773279,
  "USH2A",   0.0616541353,  0.0616541353,
  "GPR98",  -0.0604973973,  0.0604973973,
  "PKHD1L1",-0.0504916136,  0.0504916136,
  "COL11A1",-0.0464430306,  0.0464430306,
  "LRP1B",   0.0395026026,  0.0395026026,
  "BAP1",   -0.0383458647,  0.0383458647,
  "RYR2",   -0.0378831695,  0.0378831695,
  "CACNA1E", 0.0373626374,  0.0373626374
)

# --- Top 50 most mutated genes (from your mutation matrix) ---
gene_freq <- rowSums(mut_matrix)
top_50_genes <- names(sort(gene_freq, decreasing = TRUE))[1:100]

# lookup: gene -> rank 1..50 within top-50 list
top50_rank_lookup <- setNames(seq_along(top_50_genes), top_50_genes)

# --- Add ranks (1–10 by difference, + rank within top-50) ---
gene_diff_ranked <- gene_diff_tbl %>%
  mutate(
    DiffRank = row_number(),                 # 1..10 (already sorted)
    Rank_in_Top50 = top50_rank_lookup[Gene]  # 1..50 or NA if not in top 50
  )

gene_diff_ranked

```



```{r}
# Plot mutation proportion for Top 10 different genes
top10_genes <- gene_diff_tbl$Gene[1:6]

bar_df <- stage_gene_freq %>%
  select(Stage_binary_2, all_of(top10_genes)) %>%
  pivot_longer(cols = all_of(top10_genes),
               names_to = "Gene",
               values_to = "Proportion")

ggplot(bar_df, aes(x = Gene, y = Proportion, fill = Stage_binary_2)) +
  geom_col(position = "dodge") +
  theme_minimal(base_size = 14) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(
    title = "Mutation Proportions of Top 4 Differentiating Genes",
    y = "Proportion Mutated"
  )

```


This shows that after performing some preliminary re-organization of the data, we now have a structured set of mutation features that can more effectively separate cancer stages into early and late groups. This improves the usefulness of the dataset and should increase the accuracy of any future predictive models by ensuring they are trained on meaningful, relevant information — garbage in, garbage out.

Additionally, we can now see that DNAH6 appears only in the early-stage group. This suggests that DNAH6 may be a particularly valuable feature for helping the model distinguish between early and late cancer stages.





```{r}
library(dplyr)
library(stringr)

# ---- CLEAN T STAGE ----
clean_T <- function(x) {
  x <- toupper(as.character(x))
  x <- gsub("[A-Z]+$", "", x)     # remove A/B/C, etc.
  x <- gsub("^T", "", x)          # remove leading T
  x <- trimws(x)

  case_when(
    x %in% c("0","1","2","3","4") ~ paste0("T", x),
    TRUE ~ NA_character_
  )
}

clinical$T_clean <- clean_T(clinical$PATH_T_STAGE)

T_counts <- table(clinical$T_clean, useNA = "ifany")
T_counts


# ---- CLEAN N STAGE ----
clean_N <- function(x) {
  x <- toupper(as.character(x))
  x <- gsub("^N", "", x)          # remove leading N
  x <- trimws(x)

  case_when(
    x %in% c("0","1", "X") ~ paste0("N", x),
    TRUE ~ NA_character_
  )
}

clinical$N_clean <- clean_N(clinical$PATH_N_STAGE)

N_counts <- table(clinical$N_clean, useNA = "ifany")
N_counts


# ---- CLEAN M STAGE ----
clean_M <- function(x) {
  x <- toupper(as.character(x))
  x <- gsub("^M", "", x)          # remove leading M
  x <- trimws(x)

  case_when(
    x %in% c("0","1", "X") ~ paste0("M", x),
    TRUE ~ NA_character_
  )
}

clinical$M_clean <- clean_M(clinical$PATH_M_STAGE)

M_counts <- table(clinical$M_clean, useNA = "ifany")
M_counts


# ---- FILTER OUT NA T/N/M IF NEEDED ----
clinical_TNM <- clinical %>%
  filter(!is.na(T_clean), !is.na(N_clean), !is.na(M_clean))

```
so from this it is clear that T0 and T1 need to be combined as well as T3 and T4
and N1 and M1 need to be ommited and cannot be correctly prodicited with this data set. Upon further reserach anything with the compenet X so NX and MX means that this data was not collected meaning There so not enough data to do analysis on for these two categories 


```{r}

clinical <- clinical %>%
  mutate(
    T_clean = clean_T(PATH_T_STAGE),
  )


# --- APPLY YOUR DECISIONS BASED ON COUNTS ---
# - Combine T0 + T1
# - Combine T3 + T4
# - Drop N1 (too few)
# - Drop M1 (too few)


clinical_TNM_collapsed <- clinical %>%
  mutate(
    T_group = case_when(
      T_clean %in% c("T0", "T1")      ~ "T0-1",
      T_clean == "T2"                 ~ "T2",
      T_clean %in% c("T3", "T4")      ~ "T3-4",
      TRUE                            ~ NA_character_
    )
  ) %>%
  # drop unusable N and M categories
  filter(
    !is.na(T_group),
    N_clean != "N1",
    M_clean != "M1",

  )

# Check final distributions
table(clinical_TNM_collapsed$T_group)
table(clinical_TNM_collapsed$N_clean)
table(clinical_TNM_collapsed$M_clean)
  
```

```{r}
library(dplyr)

## 1. Create collapsed T groups: T0-1, T2, T3-4 ----

clean_T <- function(x) {
  x <- toupper(as.character(x))
  x <- gsub("[A-Z]+$", "", x)   # drop suffix A/B/C
  x <- gsub("^T", "", x)        # drop leading T
  x <- trimws(x)

  dplyr::case_when(
    x %in% c("0", "1") ~ "T0-1",
    x == "2"           ~ "T2",
    x %in% c("3", "4") ~ "T3-4",
    TRUE               ~ NA_character_
  )
}

clinical <- clinical %>%
  mutate(T_group = clean_T(PATH_T_STAGE))

## 2. Keep only patients with valid T_group and present in mut_matrix ----

clinical_t <- clinical %>%
  filter(!is.na(T_group))

common_ids <- intersect(colnames(mut_matrix), clinical_t$PATIENT_ID)

mut_t <- mut_matrix[, common_ids, drop = FALSE]

clinical_t <- clinical_t %>%
  filter(PATIENT_ID %in% common_ids) %>%
  arrange(match(PATIENT_ID, colnames(mut_t)))

## 3. Remove genes with zero variance ----

gene_var <- apply(mut_t, 1, var)
mut_t_var <- mut_t[gene_var > 0, , drop = FALSE]

## 4. PCA on mutation data only (rows = patients, cols = genes) ----

X <- t(mut_t_var)  # patients × genes

pca_res <- prcomp(X, center = TRUE, scale. = TRUE)

## 5. Build PCA data frame with *all* PCs + T_group ----
##    (number of PCs = nrow(X) - 1)

all_pcs <- ncol(pca_res$x)

pca_df <- data.frame(
  pca_res$x[, 1:all_pcs, drop = FALSE],
  T_group = clinical_t$T_group
)



```



```{r}

# Basic 2D PCA plot: PC1 vs PC2 colored by T_group
ggplot(pca_df, aes(x = PC1, y = PC2, color = T_group)) +
  geom_point(alpha = 0.8, size = 2) +
  theme_minimal(base_size = 14) +
  labs(
    title = "PCA of Mutation Data (PC1 vs PC2)",
    x = "PC1",
    y = "PC2"
  )

# PC2 vs PC3 (sometimes separation is clearer on other components)
ggplot(pca_df, aes(x = PC2, y = PC3, color = T_group)) +
  geom_point(alpha = 0.8, size = 2) +
  theme_minimal(base_size = 14) +
  labs(
    title = "PCA of Mutation Data (PC2 vs PC3)",
    x = "PC2",
    y = "PC3"
  )

# Optional: facet by T_group to see each cluster separately on PC1/PC2
ggplot(pca_df, aes(x = PC1, y = PC2)) +
  geom_point(alpha = 0.8, size = 2) +
  facet_wrap(~ T_group) +
  theme_minimal(base_size = 14) +
  labs(
    title = "PCA (PC1 vs PC2) Faceted by T Group",
    x = "PC1",
    y = "PC2"
  )

```

```{r}
# Install (if needed)
install.packages("umap")

library(umap)
library(ggplot2)
library(dplyr)

# --- UMAP input matrix ---
# X = patients × genes (same as PCA input)
X <- t(mut_t_var)   # rows = patients, cols = genes

# --- Run UMAP ---
set.seed(123)
umap_res <- umap(X)

# Build UMAP DF
umap_df <- data.frame(
  UMAP1 = umap_res$layout[,1],
  UMAP2 = umap_res$layout[,2],
  T_group = clinical_t$T_group
)

# --- Plot UMAP ---
ggplot(umap_df, aes(x = UMAP1, y = UMAP2, color = T_group)) +
  geom_point(alpha = 0.8, size = 2) +
  theme_minimal(base_size = 14) +
  labs(
    title = "UMAP of Mutation Data (Colored by T Group)",
    x = "UMAP1",
    y = "UMAP2"
  )

```

```{r}
library(nnet)

# Use PC1–PC10 as predictors
model_data <- pca_df
model_data$T_group <- factor(model_data$T_group)

set.seed(123)
logit_model <- multinom(T_group ~ ., data = model_data)

summary(logit_model)

# Predictions
pred <- predict(logit_model, model_data)

# Accuracy
mean(pred == model_data$T_group)

```
```{r}
install.packages("randomForest")
library(randomForest)


```

```{r}
# Variance explained by each PC
var_explained <- pca_res$sdev^2 / sum(pca_res$sdev^2)

# Cumulative variance
cum_var <- cumsum(var_explained)

# Find number of PCs needed for 90% variance
which(cum_var >= 0.20)[1]

```

```{r}
k <- 20  # <- change this to use 5, 10, 20, ... PCs

model_data <- pca_df %>%
  select(all_of(paste0("PC", 1:k)), T_group)
model_data$T_group <- factor(model_data$T_group)

set.seed(123)

n <- nrow(model_data)
idx <- sample(seq_len(n), size = floor(0.7 * n))   # 70% training

train <- model_data[idx, ]
test  <- model_data[-idx, ]

# ------------------------
# Random Forest Model
# ------------------------
rf_model <- randomForest(
  T_group ~ ., 
  data = train,
  ntree = 500,       # number of trees
  mtry = 3,          
  importance = TRUE
)

# ------------------------
# Predictions + Accuracy
# ------------------------
rf_pred <- predict(rf_model, test)

rf_accuracy <- mean(rf_pred == test$T_group)
rf_accuracy


```
```{r}
#library(caret)
rf_confusion <- table(Predicted = rf_pred, Actual = test$T_group)
rf_confusion
```
remove T2 group 


```{r}
library(dplyr)

## 1. Create collapsed T groups: T0-1, T3-4 -

clean_T <- function(x) {
  x <- toupper(as.character(x))
  x <- gsub("[A-Z]+$", "", x)   # drop suffix A/B/C
  x <- gsub("^T", "", x)        # drop leading T
  x <- trimws(x)

  dplyr::case_when(
    x %in% c("0", "1") ~ "T0-1",
    x %in% c("3", "4") ~ "T3-4",
    TRUE               ~ NA_character_
  )
}

clinical <- clinical %>%
  mutate(T_group = clean_T(PATH_T_STAGE))

clinical_t <- clinical %>%
  filter(!is.na(T_group))

common_ids <- intersect(colnames(mut_matrix), clinical_t$PATIENT_ID)

mut_t <- mut_matrix[, common_ids, drop = FALSE]

clinical_t <- clinical_t %>%
  filter(PATIENT_ID %in% common_ids) %>%
  arrange(match(PATIENT_ID, colnames(mut_t)))

## 3. Remove genes with zero variance ----

gene_var <- apply(mut_t, 1, var)
mut_t_var <- mut_t[gene_var > 0, , drop = FALSE]

## 4. PCA on mutation data only (rows = patients, cols = genes) ----

X <- t(mut_t_var)  # patients × genes

pca_res <- prcomp(X, center = TRUE, scale. = TRUE)

## 5. Build PCA data frame with *all* PCs + T_group ----
##    (number of PCs = nrow(X) - 1)

all_pcs <- ncol(pca_res$x)

pca_df <- data.frame(
  pca_res$x[, 1:all_pcs, drop = FALSE],
  T_group = clinical_t$T_group
)
```

```{r}
  
```


```{r}
# Variance explained by each PC
var_explained <- pca_res$sdev^2 / sum(pca_res$sdev^2)

# Cumulative variance
cum_var <- cumsum(var_explained)

# Find number of PCs needed for 90% variance
which(cum_var >= 0.90)[1]
```




```{r}
k <- 200  # <- change this to use 5, 10, 20, ... PCs

model_data <- pca_df %>%
  select(all_of(paste0("PC", 1:k)), T_group)
model_data$T_group <- factor(model_data$T_group)

set.seed(123)

n <- nrow(model_data)
idx <- sample(seq_len(n), size = floor(0.7 * n))   # 70% training

train <- model_data[idx, ]
test  <- model_data[-idx, ]


rf_model <- randomForest(
  T_group ~ ., 
  data = train,
  ntree = 500,       
  mtry = 3,          
  importance = TRUE
)


rf_pred <- predict(rf_model, test)

rf_accuracy <- mean(rf_pred == test$T_group)
rf_accuracy

```
```{r}
#library(caret)
rf_confusion <- table(Predicted = rf_pred, Actual = test$T_group)
rf_confusion
```



