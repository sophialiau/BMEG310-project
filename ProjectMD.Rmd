---
title: "\\textbf{Project Report 1: Mutation Analysis}"
author: "Group 15 - Liver Carcinoma"
date: "2025-11-21"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(survival)
library(survminer)
library(ggplot2)
library(tidyr)
library(dplyr)

```

\section{1. Key Findings}

Should summarize the key findings of the analysis in up to 5 bullet points.

\section{2. Overall Analysis Workflow}

Give a description of your analysis workflow including the algorithms (approaches) you have tried (or will try) and the patient variables you have investigated. This is the most important part of this report. You are required to include a flowchart of all the analysis.

From The Cancer Genome Atlas (TCGA), we imported the following datasets:

```{r}
clinical <- read.delim("data_clinical_patient.txt", header = TRUE,
                      sep = "\t", stringsAsFactors = FALSE)
mutations <- read.delim("data_mutations.txt", header = TRUE,
                      sep = "\t", stringsAsFactors = FALSE)
                       
```
## 2.1. Data Preprocessing

**a. Standardize Patient IDs**

In clinical dataset, patient IDs have the form of "TCGA-2V-A95S" while mutation dataset contains tumour sample barcode which has the form of "TCGA-2V-A95S-01." As a result, we will standardized patient IDs such that it is consistent by taking only the first 12 characters. We will add a column with the standardized patient IDs to each of the dataset. Then take only patients that are present in both datasets. 

```{r}
clinical$Patient_ID <- clinical$X.Patient.Identifier
mutations$Patient_ID <- substr(mutations$Tumor_Sample_Barcode, 1, 12)

common_ids <- intersect(clinical$Patient_ID, mutations$Patient_ID)
clinical <- clinical[clinical$Patient_ID %in% common_ids, ]
mutations <- mutations[mutations$Patient_ID %in% common_ids, ]
```

**b. Filter for Non-Synonymous Mutations**

We will use Variant_Classification columns to see the type of mutations presented in the dataset:
```{r}
unique(mutations$Variant_Classification)
```
We will keep the non-synonymous mutations which are those that mutate the coding regions.
```{r}
nonsynonymous <- c(
  "Missense_Mutation", "Nonsense_Mutation",
  "Frame_Shift_Del", "Frame_Shift_Ins",
  "In_Frame_Del", "In_Frame_Ins",
  "Splice_Site", "Splice_Region", "Nonstop_Mutation", 
  "Translation_Start_Site"
)
mut_filt <- mutations[mutations$Variant_Classification %in% nonsynonymous, ]

```

**c. Gene x Patient Matrix**

The Gene x Patient matrix turns raw mutation calls into a form that allows clustering and other downstream data analysis methods. The matrix's row will be genes and its column is patient. If a mutation is present in a patient, then that cell will contain the value of one. Note that we are building a matrix for non-synonymous genes only.

```{r}
genes <- unique(mut_filt$Hugo_Symbol)
patients <- unique(mut_filt$Patient_ID)

mut_matrix <- matrix(0, nrow = length(genes), ncol = length(patients))
rownames(mut_matrix) <- genes
colnames(mut_matrix) <- patients

for (i in seq_len(nrow(mut_filt))) {
    g <- mut_filt$Hugo_Symbol[i]
    p <- mut_filt$Patient_ID[i]
    mut_matrix[g, p] <- 1
}
```

**d. Tumor Mutation Burden (TMB)**

We will compute TMB which is the total number of mutated genes per patient. This can give us more insights into survival in later in our analysis as TMB can associate with mutation-driven cancer, immune response or prognosis. 

```{r}
tmb <- colSums(mut_matrix)
hist(tmb, breaks = 30, col = "seagreen", border = "black",
     main = "TMB Distribution",
     xlab = "Tumor Mutation Burden (# mutated genes)")
tmb_filt <- tmb[tmb <= 800]
```

**e. Transform Clinical Variables**

Many clinical variables are in string form when we want them to be in numeric form. We will transform these variables to help with downstream data analysis. We will create a function to remove labels like 1:Progressed and keep only number, then convert into numeric form.

```{r}
parse_status <- function(x) {
    as.numeric(sub(":.*", "", x))
}

# Convert time strings ("63.72") to numeric
parse_time <- function(x) {
    as.numeric(trimws(x))
}

# Age
clinical$Diagnosis.Age <- parse_time(clinical$Diagnosis.Age)
# Survival Times
clinical$Overall_Time  <- parse_time(clinical$Overall.Survival..Months.)
clinical$DSS_Time      <- parse_time(clinical$Months.of.disease.specific.survival)
clinical$DFS_Time      <- parse_time(clinical$Disease.Free..Months.)
clinical$PFS_Time      <- parse_time(clinical$Progress.Free.Survival..Months.)
# Survival Status
clinical$Overall_Status <- parse_status(clinical$Overall.Survival.Status)
clinical$DSS_Status     <- parse_status(clinical$Disease.specific.Survival.status)
clinical$DFS_Status     <- parse_status(clinical$Disease.Free.Status)
clinical$PFS_Status     <- parse_status(clinical$Progression.Free.Status)

```

**f. Group Stage**
```{r}
# Create grouped clinical stage
clinical$Stage_Grouped <- clinical$Neoplasm.Disease.Stage.American.Joint.Committee.on.Cancer.Code  # start with original

clinical$Stage_Grouped <- ifelse(grepl("^STAGE I$", clinical$Stage), "I",
                          ifelse(grepl("^STAGE II$", clinical$Stage), "II",
                          ifelse(grepl("^STAGE III", clinical$Stage), "III",
                          ifelse(grepl("^STAGE IV", clinical$Stage), "IV",
                                 NA))))
clinical_NAStage <- clinical[!is.na(clinical$Stage_Grouped), ]
```

## 2.2. Clinical Exploration

**a. Age Distribution**

We will use Diagnosis.Age to contruct a histogram on the distribution of patient age. 
```{r}
age_data <- clinical[!is.na(clinical$Diagnosis.Age), ]
par(cex = 0.67)
hist(age_data$Diagnosis.Age,
     main = "Age Distribution",
     xlab = "Age",
     col = "seagreen", border = "black")
```

**b. Sex Distribution**
We will contruct a barplot on sex distribution. 
```{r}
table(clinical$Sex)
par(cex = 0.67)
barplot(table(clinical$Sex),
        main = "Sex Distribution",
        col = c("pink", "lightblue"))
```

**c. Race Distribution**
```{r}
library(ggplot2)

ggplot(subset(clinical, Race.Category != "" & !is.na(Race.Category)),
       aes(x = Race.Category)) +
  geom_bar(fill = "seagreen") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 7.3),
    text = element_text(size = 7.3))
```

**d. Stage Distribution**
```{r}
par(cex = 0.67)
barplot(table(clinical$Stage_Grouped),
        main = "Stage Distribution", las = 2, col = "seagreen")
```

**e. Survival Summaries**
```{r}
summary(clinical$Overall_Time)
summary(clinical$DFS_Time)
summary(clinical$PFS_Time)
summary(clinical$DSS_Time)

# Select survival time columns
surv_df <- clinical %>%
  select(Overall_Time, DFS_Time, PFS_Time, DSS_Time)

# Convert to long format for ggplot
surv_long <- surv_df %>%
  pivot_longer(cols = everything(),
               names_to = "Endpoint",
               values_to = "Time")

# Boxplot
ggplot(surv_long, aes(x = Endpoint, y = Time, fill = Endpoint)) +
  geom_boxplot() +
  theme_minimal(base_size = 14) +
  labs(
    title = "Distribution of Survival Times",
    y = "Time (months)",
    x = ""
  ) +
  theme(legend.position = "none")
```

## 2.4. Mutation-Based Clusters

Question: Can unsupervised clustering of patients based on their somatic mutation profiles (using the top 10 most frequently mutated genes) reveal distinct molecular subtypes that correspond to differences in clinical characteristics such as sex, age and stage?

**2.4.1. Clusters on Top 10 Mutated Genes**
```{r}
# Compute mutation frequency per gene
gene_counts <- rowSums(mut_matrix)

# Select top 10 most mutated genes
top_genes <- names(sort(gene_counts, decreasing = TRUE))[1:10]

# Subset mutation matrix
mut_top <- mut_matrix[top_genes, ]

# Match clinical rows to mutation matrix columns
clinical2 <- clinical[match(colnames(mut_top), clinical$Patient_ID), ]

# Check alignment
stopifnot(all(clinical2$Patient_ID == colnames(mut_top)))

dist_mat <- dist(t(mut_top), method = "binary")
hc <- hclust(dist_mat, method = "ward.D2")

plot(hc, labels = FALSE,
     main = "Clustering Based on Top 10 Mutated Genes")

clusters <- cutree(hc, k = 2)
clinical2$Mutation_Cluster <- clusters
```


**2.4.1. Cluster vs Clinical Characteristics**

convert sex and cluster into factor, convert stage to ordered factor so that R does not treat them alphabetically

Group stage early (1,2) and late (3,4) 
Group stage (3,4)
Remove rows with missing clinical data

Construct cluster × sex and cluster × stage tables.
```{r}
clinical2$Sex <- factor(clinical2$Sex)

clinical2$Stage_Grouped <- factor(clinical2$Stage_Grouped,
                                  levels = c("I", "II", "III", "IV"), ordered = TRUE)

clinical2$Mutation_Cluster <- factor(clinical2$Mutation_Cluster)

clinical2$Stage_Binary <- ifelse(
    clinical2$Stage_Grouped %in% c("I", "II"),
    "Early",
    "Late"
)

clinical2$Stage_Binary <- factor(clinical2$Stage_Binary, levels = c("Early", "Late"))

clinical2$Stage_3Group <- dplyr::case_when(
    clinical2$Stage_Grouped %in% c("I")  ~ "I",
    clinical2$Stage_Grouped %in% c("II") ~ "II",
    clinical2$Stage_Grouped %in% c("III", "IV") ~ "III/IV",
    TRUE ~ NA_character_
)

clinical2$Stage_3Group <- factor(
    clinical2$Stage_3Group,
    levels = c("I", "II", "III/IV")
)

clinical3 <- clinical2 %>%
    dplyr::filter(
        !is.na(Sex),
        !is.na(Stage_Grouped),
        !is.na(Stage_Binary),
        !is.na(Stage_3Group),
        !is.na(Mutation_Cluster)
    )

# Sex vs cluster
table_sex <- table(clinical3$Mutation_Cluster, clinical3$Sex)
table_sex

# Stage vs cluster
table_stage <- table(clinical3$Mutation_Cluster, clinical3$Stage_Grouped)
table_stage

table_stage_bin <- table(clinical3$Mutation_Cluster, clinical3$Stage_Binary)
table_stage_bin

table_stage_3 <- table(clinical3$Mutation_Cluster, clinical3$Stage_3Group)
table_stage_3

```

Chi-squared test requires:
- large enough sample size where every cell has more than 5 observations
Fisher test
- find for small sample size but computationally slow

To evaluate whether mutation-defined clusters differed by sex, we performed a chi-square test when all contingency table cells contained at least five patients, and Fisher’s exact test otherwise. This ensures appropriate handling of small cell counts and maintains the validity of the statistical inference.

```{r}
if (any(table_sex < 5)) {
    test_sex <- fisher.test(table_sex)
} else {
    test_sex <- chisq.test(table_sex)
}
test_sex
prop_sex <- prop.table(table_sex, margin = 1)

barplot(t(prop_sex),
        beside = TRUE,
        col = c("#E76F51", "#2A9D8F"),
        legend = TRUE,
        xlab = "Mutation Cluster",
        ylab = "Proportion",
        main = "Proportion of Sex Within Each Mutation Cluster")
```

A Wilcoxon rank-sum test was used to compare patient age between mutation clusters because age was non-normally distributed and sample sizes were unequal across clusters, violating t-test assumptions.


```{r}
clinical2$Mutation_Cluster <- factor(clinical2$Mutation_Cluster)
wilcox_age <- wilcox.test(Diagnosis.Age ~ Mutation_Cluster, data = clinical2)
wilcox_age

#for visual
ggplot(clinical3, aes(x = Mutation_Cluster, y = Diagnosis.Age, fill = Mutation_Cluster)) +
    geom_boxplot() +
    labs(title = "Age Distribution Across Mutation Clusters",
         x = "Mutation Cluster", y = "Diagnosis Age") +
    theme_minimal()
```




Similar to Sex variables, we will use Chi-squared test for stage to see if stage distribution differs between cluster. Fisher-exact test was used when stages are not grouped together and there were less than 5 observations for at least one cell in the table. 


```{r}
if (any(table_stage < 5)) {
    test_stage <- fisher.test(table_stage)
} else {
    test_stage <- chisq.test(table_stage)
}
test_stage

test_stage_bin <- chisq.test(table_stage_bin)
test_stage_bin

test_stage_3 <- chisq.test(table_stage_3)
test_stage_3

ggplot(clinical3, aes(x = Mutation_Cluster, fill = Stage_Grouped)) +
    geom_bar(position = "fill") +
    labs(title = "Stage Distribution (I, II, III, IV) Across Mutation Clusters",
         x = "Mutation Cluster", y = "Proportion") +
    theme_minimal()
```

```{r}
list(
  Sex_Association = test_sex,
  Age_Association = wilcox_age,
  Stage_Association = test_stage_3
)
```


Now we are seeing if the clusters have different survival profile. We will construct Kaplan–Meier plot for each OS, DSS, DFS and PFS

```{r}
#construct only column needed for KM plot
os_data <- clinical2[, c("Overall_Time", "Overall_Status", "Mutation_Cluster")]
os_data <- na.omit(os_data)

#fit plot
fit_os <- survfit(
  Surv(os_data$Overall_Time, os_data$Overall_Status) ~ Mutation_Cluster,
  data = os_data
)

ggsurvplot(fit_os, data = os_data,
           pval = TRUE, risk.table = FALSE,
           title = "Overall Survival by Mutation Cluster",
           legend.title = "Cluster")
```

```{r}
dss_data <- clinical2[, c("DSS_Time", "DSS_Status", "Mutation_Cluster")]
dss_data <- na.omit(dss_data)

fit_dss <- survfit(
  Surv(DSS_Time, DSS_Status) ~ Mutation_Cluster,
  data = dss_data
)

ggsurvplot(fit_dss, data = dss_data,
           pval = TRUE, risk.table = FALSE,
           title = "DSS by Mutation Cluster")

```

```{r}
dfs_data <- clinical2[, c("DFS_Time", "DFS_Status", "Mutation_Cluster")]
dfs_data <- na.omit(dfs_data)

fit_dfs <- survfit(
  Surv(DFS_Time, DFS_Status) ~ Mutation_Cluster,
  data = dfs_data
)

ggsurvplot(fit_dfs, data = dfs_data,
           pval = TRUE, risk.table = FALSE,
           title = "DFS by Mutation Cluster")
```


```{r}
pfs_data <- clinical2[, c("PFS_Time", "PFS_Status", "Mutation_Cluster")]
pfs_data <- na.omit(pfs_data)

fit_pfs <- survfit(
  Surv(PFS_Time, PFS_Status) ~ Mutation_Cluster,
  data = pfs_data
)

ggsurvplot(fit_pfs, data = pfs_data,
           pval = TRUE, risk.table = FALSE,
           title = "PFS by Mutation Cluster")
```

Question 6: Do mutation-defined patient clusters, derived from the top 10 most frequently mutated genes, differ in OS, DSS, PFS or DFS, independent of basic clinical variables (age, sex, stage)?

We are running adjusted, multivariable Cox regression across multiple survival endpoints to determine whether the mutation-derived clusters have independent prognostic significance.


```{r}
#Convert variables to factors
clinical2$Mutation_Cluster <- factor(clinical2$Mutation_Cluster)
clinical2$Sex <- factor(clinical2$Sex)

# choose stage variable 
stage_var <- "Stage_3Group"

#Define all survival endpoints
surv_endpoints <- list(
  OS  = c("Overall_Time", "Overall_Status"),
  DSS = c("DSS_Time",     "DSS_Status"),
  DFS = c("DFS_Time",     "DFS_Status"),
  PFS = c("PFS_Time",     "PFS_Status")
)

cox_results <- list()

for (ep in names(surv_endpoints)) {
  
  time_col  <- surv_endpoints[[ep]][1]
  event_col <- surv_endpoints[[ep]][2]
  
  # skip if any endpoint does not exist
  if (!all(c(time_col, event_col) %in% colnames(clinical2))) {
    message("Skipping ", ep, " — missing columns.")
    next
  }
  
  formula_string <- paste0(
    "Surv(", time_col, ", ", event_col, ") ~ ",
    "Mutation_Cluster + Diagnosis.Age + Sex + ", stage_var
  )
  
  fit <- coxph(as.formula(formula_string), data = clinical2)
  cox_results[[ep]] <- fit
  
  cat("\n================================\n")
  cat(" Multivariable Cox for", ep, "\n")
  cat("================================\n")
  print(summary(fit))
  
  # optional forest plot
  print(
    ggforest(fit, data = clinical2,
             main = paste0(ep, " – Multivariable Cox Model"))
  )
}

```







Quetsion 7: Does Tumour Mutation Burden (TMB) influence overall survival (OS), disease-specific survival (DSS), progression-free survival (PFS), or disease-free survival (DFS) in this cancer cohort?


```{r}
# mut_matrix is gene x patient with 0/1 mutation presence
# TMB = number of mutated genes per patient
clinical2$TMB <- colSums(mut_matrix)
clinical2$logTMB <- log1p(clinical2$TMB)   # handles TMB=0 safely


clinical2$Mutation_Cluster <- factor(clinical2$Mutation_Cluster)
clinical2$Sex <- factor(clinical2$Sex)

stage_var <- "Stage_3Group"


surv_endpoints <- list(
  OS  = c("Overall_Time", "Overall_Status"),
  DSS = c("DSS_Time",     "DSS_Status"),
  DFS = c("DFS_Time",     "DFS_Status"),
  PFS = c("PFS_Time",     "PFS_Status")
)
cox_TMB_results <- list()
cox_TMB_results_adj <- list()

for (ep in names(surv_endpoints)) {
  
  time_col  <- surv_endpoints[[ep]][1]
  event_col <- surv_endpoints[[ep]][2]
  
  # skip if missing columns
  if (!all(c(time_col, event_col) %in% names(clinical2))) {
    message("Skipping ", ep, ": missing time/event")
    next
  }
  
  cat("\n=================================================\n")
  cat("              TMB Survival Analysis –", ep, "\n")
  cat("=================================================\n")
  
  # -----------------------------
  # 1. Univariate Cox: TMB only
  # -----------------------------
  form_uni <- as.formula(
    paste0("Surv(", time_col, ", ", event_col, ") ~ logTMB")
  )
  
  fit_uni <- coxph(form_uni, data = clinical2)
  cox_TMB_results[[ep]] <- fit_uni
  
  cat("\n--- Univariate Cox (TMB only) ---\n")
  print(summary(fit_uni))
  
  # -----------------------------
  # 2. Multivariable Cox: TMB + age + sex + stage
  # -----------------------------
  form_multi <- as.formula(
    paste0("Surv(", time_col, ", ", event_col, ") ~ ",
           "logTMB + Diagnosis.Age + Sex + ", stage_var)
  )
  
  fit_multi <- coxph(form_multi, data = clinical2)
  cox_TMB_results_adj[[ep]] <- fit_multi
  
  cat("\n--- Multivariable Cox (adjusted for age, sex, stage) ---\n")
  print(summary(fit_multi))
  
  # Optional: forest plot
  print(
    ggforest(fit_multi, 
             data = clinical2,
             main = paste0(ep, " – TMB Multivariable Cox Model"))
  )
}


```


```{r}
rnaseq <- read.csv("RNAseq_LIHC.csv", header = TRUE, 
                   stringsAsFactors = FALSE)
colnames(rnaseq)[1:10]

```

##Section 1

Patient ID standardization

```{r}
# Store the gene column separately
genes <- rnaseq[, 1]

# Extract original patient columns
patient_cols <- colnames(rnaseq)[-1]

# Step 1: Replace "." with "-"
patient_cols2 <- gsub("\\.", "-", patient_cols)

# Step 2: Extract the first 3 barcode components: TCGA-XX-YYYY
# TCGA-AB-1234-... → TCGA-AB-1234
patient_ids <- sapply(patient_cols2, function(x) {
  parts <- strsplit(x, "-")[[1]]
  paste(parts[1:3], collapse = "-")
})

# Update column names in rnaseq
colnames(rnaseq) <- c("Gene", patient_ids)

# Restore gene column
rnaseq$Gene <- genes

# View standardized column names
head(colnames(rnaseq))
```

##Section 2

Convert to Matrix & Remove Low-Expressed Genes Keep genes with > 10 counts in > 20% of samples.

```{r}
# Convert to matrix
count_mat <- rnaseq[, -1]
row.names(count_mat) <- rnaseq$Gene
count_mat <- as.matrix(count_mat)

# Filter low-expressed genes
min_samples <- round(0.2 * ncol(count_mat))

keep <- rowSums(count_mat >= 10) >= min_samples
count_mat_filt <- count_mat[keep, ]

cat("Genes before filtering:", nrow(count_mat), "\n")
cat("Genes after filtering:", nrow(count_mat_filt), "\n")
```


##Section 3

DESeq2 normalized counts

```{r}
library(DESeq2)
# Create dummy metadata (DESeq2 requires it)
sample_info <- data.frame(row.names = colnames(count_mat_filt),
                          condition = rep("LIHC", ncol(count_mat_filt)))

dds <- DESeqDataSetFromMatrix(countData = count_mat_filt,
                              colData = sample_info,
                              design = ~ 1)

# Standard DESeq2 normalization
dds <- estimateSizeFactors(dds)
norm_counts <- counts(dds, normalized = TRUE)

# VST transform for PCA & clustering
vsd <- vst(dds, blind = TRUE)
vst_mat <- assay(vsd)
```


##Section 4

Global expression exploration

```{r}
# PCA using top 500 highly variable genes (optional)
hvg <- order(rowVars(vst_mat), decreasing = TRUE)[1:500]
pca <- prcomp(t(vst_mat[hvg, ]))

pca_df <- data.frame(
  PC1 = pca$x[,1],
  PC2 = pca$x[,2],
  Sample = rownames(pca$x)
)

ggplot(pca_df, aes(PC1, PC2)) +
  geom_point(size = 2) +
  labs(title = "PCA of LIHC RNA-seq (Top 500 HVGs)",
       x = paste0("PC1 (", round(summary(pca)$importance[2,1] * 100, 1), "%)"),
       y = paste0("PC2 (", round(summary(pca)$importance[2,2] * 100, 1), "%)"))
```

##Section 5

Distance Heatmap
```{r}
sample_dist <- dist(t(vst_mat))
sample_dist_mat <- as.matrix(sample_dist)

pheatmap(sample_dist_mat,
         clustering_method = "ward.D2",
         show_rownames = FALSE,
         show_colnames = FALSE,
         main = "Sample Distance Heatmap (VST Expression)")
```


##Section 6

Clustering

```{r}
library(matrixStats)
library(pheatmap)
library(ggplot2)

var_genes <- rowVars(vst_mat)
hvg_index <- order(var_genes, decreasing = TRUE)[1:1000]
hvg_mat <- vst_mat[hvg_index, ]


# Distance matrix across samples
dist_samples <- dist(t(hvg_mat))  

# Hierarchical clustering
hc <- hclust(dist_samples, method = "ward.D2")

# Plot dendrogram
plot(hc, labels = FALSE, main = "Hierarchical Clustering of LIHC (Top 1000 HVGs)")

k <- 4   # you can change this to 3 or 4
clusters <- cutree(hc, k = k)

# Assign cluster labels
Expression_Cluster <- as.factor(clusters)
names(Expression_Cluster) <- colnames(hvg_mat)

table(Expression_Cluster)
```
This helps visualize whether the clusters are well-separated.

```{r}
pheatmap(hvg_mat,
         show_rownames = FALSE,
         show_colnames = FALSE,
         clustering_method = "ward.D2",
         annotation_col = data.frame(Cluster = Expression_Cluster),
         main = "Heatmap of Top 1000 HVGs (LIHC)")

# PCA on HVGs
pca_hvg <- prcomp(t(hvg_mat))

pca_df <- data.frame(
  PC1 = pca_hvg$x[,1],
  PC2 = pca_hvg$x[,2],
  Cluster = Expression_Cluster
)

ggplot(pca_df, aes(PC1, PC2, color = Cluster)) +
  geom_point(size = 2) +
  labs(title = "PCA of LIHC RNA-seq (Top 1000 HVGs)",
       x = paste0("PC1 (", round(summary(pca_hvg)$importance[2,1] * 100, 1), "%)"),
       y = paste0("PC2 (", round(summary(pca_hvg)$importance[2,2] * 100, 1), "%)")) +
  theme_minimal() +
  scale_color_brewer(palette = "Dark2")
```
##Section 7

Merge expression clusters with clinical data (handle missing patients)

```{r}
library(dplyr)

## Expression_Cluster should already exist from Investigation 2
## names(Expression_Cluster) are patient IDs like "TCGA-2Y-A95S"

expr_cluster_df <- data.frame(
  Patient_ID        = names(Expression_Cluster),
  Expression_Cluster = as.factor(as.character(Expression_Cluster)),
  stringsAsFactors  = FALSE
)

# Intersect ONLY patients that have both clinical info and expression clusters
common_ids_expr <- intersect(clinical$Patient_ID, expr_cluster_df$Patient_ID)

clinical_expr <- clinical[clinical$Patient_ID %in% common_ids_expr, ]
clinical_expr$Stage <- clinical_expr$Neoplasm.Disease.Stage.American.Joint.Committee.on.Cancer.Code
expr_cluster_df <- expr_cluster_df[expr_cluster_df$Patient_ID %in% common_ids_expr, ]

# Align orders
clinical_expr <- clinical_expr[match(expr_cluster_df$Patient_ID, clinical_expr$Patient_ID), ]
stopifnot(all(clinical_expr$Patient_ID == expr_cluster_df$Patient_ID))

# Attach cluster info
clinical_expr$Expression_Cluster <- expr_cluster_df$Expression_Cluster

cat("N clinical (after clin+mut filter):", nrow(clinical), "\n")
cat("N expression clusters:", length(Expression_Cluster), "\n")
cat("N with BOTH clinical + expression:", nrow(clinical_expr), "\n")
table(clinical_expr$Expression_Cluster)
```

##Section 8

Cluster vs clinical

```{r}
clinical_expr$Stage_Grouped <- ifelse(grepl("^STAGE I$",   clinical_expr$Stage), "I",
                               ifelse(grepl("^STAGE II$",  clinical_expr$Stage), "II",
                               ifelse(grepl("^STAGE III", clinical_expr$Stage), "III",
                               ifelse(grepl("^STAGE IV",  clinical_expr$Stage), "IV",
                                      NA))))

clinical_expr$Stage_Grouped <- factor(clinical_expr$Stage_Grouped,
                                      levels = c("I", "II", "III", "IV"),
                                      ordered = TRUE)

clinical_expr <- clinical_expr %>%
  mutate(
    Sex               = factor(Sex),
    Expression_Cluster = factor(Expression_Cluster)
  )

## Age vs cluster (Kruskal–Wallis)
boxplot(Diagnosis.Age ~ Expression_Cluster, data = clinical_expr,
        main = "Age by Expression Cluster",
        xlab = "Expression Cluster", ylab = "Diagnosis Age (years)")
kruskal.test(Diagnosis.Age ~ Expression_Cluster, data = clinical_expr)

## Sex vs cluster (χ² or Fisher)
tab_sex_expr <- table(clinical_expr$Expression_Cluster, clinical_expr$Sex)
tab_sex_expr

if (any(tab_sex_expr < 5)) {
  test_sex_expr <- fisher.test(tab_sex_expr)
} else {
  test_sex_expr <- chisq.test(tab_sex_expr)
}
test_sex_expr

## Stage vs cluster (Stage_3Group for power)
tab_stage_expr <- table(clinical_expr$Expression_Cluster, clinical_expr$Stage_Grouped)
tab_stage_expr

chisq.test(tab_stage_expr)
```


## Section 9

Survival analysis by cluster

```{r}
library(survival)
library(survminer)

# Make sure survival variables are numeric
surv_vars_time <- c("Overall_Time", "DSS_Time", "DFS_Time", "PFS_Time")
surv_vars_stat <- c("Overall_Status", "DSS_Status", "DFS_Status", "PFS_Status")

clinical_expr[surv_vars_time] <- lapply(clinical_expr[surv_vars_time], as.numeric)
clinical_expr[surv_vars_stat] <- lapply(clinical_expr[surv_vars_stat], as.numeric)

# Helper: run KM for each endpoint
surv_endpoints <- list(
  OS  = c("Overall_Time", "Overall_Status"),
  DSS = c("DSS_Time",     "DSS_Status"),
  DFS = c("DFS_Time",     "DFS_Status"),
  PFS = c("PFS_Time",     "PFS_Status")
)

for (ep in names(surv_endpoints)) {
  time_var <- surv_endpoints[[ep]][1]
  stat_var <- surv_endpoints[[ep]][2]
  
  data_ep <- clinical_expr %>%
    filter(!is.na(.data[[time_var]]),
           !is.na(.data[[stat_var]]))
  
  if (nrow(data_ep) == 0) next
  
  surv_obj <- Surv(time = data_ep[[time_var]],
                   event = data_ep[[stat_var]])
  
  fit <- survfit(surv_obj ~ Expression_Cluster, data = data_ep)
  
  print(
    ggsurvplot(
      fit,
      data       = data_ep,
      risk.table = TRUE,
      pval       = TRUE,
      conf.int   = FALSE,
      legend.title = "Cluster",
      xlab       = "Time (months)",
      ylab       = paste(ep, "survival probability"),
      title      = paste(ep, "by expression-defined cluster")
    )
  )
}
```


##Section 9 

Cox Models
```{r}
# Filter to complete cases for covariates
clin_OS <- clinical_expr %>%
  filter(!is.na(Overall_Time),
         !is.na(Overall_Status),
         !is.na(Diagnosis.Age),
         !is.na(Sex),
         !is.na(Stage_Grouped))

# Unadjusted: cluster only
cox_OS_unadj <- coxph(
  Surv(Overall_Time, Overall_Status) ~ Expression_Cluster,
  data = clin_OS
)
summary(cox_OS_unadj)   # HRs & p-values for each cluster

# Adjusted: cluster + age + sex + stage
cox_OS_adj <- coxph(
  Surv(Overall_Time, Overall_Status) ~ Expression_Cluster +
    Diagnosis.Age + Sex + Stage_Grouped,
  data = clin_OS
)
summary(cox_OS_adj)
```











