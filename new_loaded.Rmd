---
title: "setup for everyones report"
output: html_document
---

### SECTION 1: Libraries


# ```{r}
# #may need to do this to load some libaries
#
#
# if (!requireNamespace("BiocManager", quietly = TRUE)) {
#   install.packages("BiocManager")
# }
#
# # Install the human annotation database
# BiocManager::install("org.Hs.eg.db", ask = FALSE)
#
# # Then load the packages
# library(AnnotationDbi)
# library(org.Hs.eg.db)
#
# ```

```{r}
#loaded Libraries 

library(dplyr)
library(readr)
library(tibble)
library(ggplot2)
library(tidyr)
library(e1071)
library(purrr)
library(survival)
library(survminer)


library(AnnotationDbi)
library(org.Hs.eg.db)

library(DESeq2)
library(pheatmap)

library(pheatmap)
```

### SECTION 2: Loading Data

```{r}
# Loading in our Expression Data
expr_raw <- read.csv(
  "RNAseq_LIHC.csv",
  header = TRUE,
  row.names = 1,          # gene IDs become rownames
  check.names = FALSE     # keep TCGA IDs untouched
)

dim(expr_raw)
expr_raw[1:5, 1:5]

# Make expression matrix numeric
expr_mat <- as.matrix(expr_raw)
mode(expr_mat) <- "numeric"

# Loading in our Clinical Data
clinical <- read_tsv(
  "data_clinical_patient.txt",
  comment = "#",
  show_col_types = FALSE
)



clinical <- as.data.frame(clinical)

rownames(clinical) <- clinical$PATIENT_ID

# Keeping only matching patient barcodes
colnames(expr_mat) <- substr(colnames(expr_mat), 1, 12)

common_ids <- intersect(colnames(expr_mat), rownames(clinical))
length(common_ids)

expr_filt    <- expr_mat[, common_ids]
clinical_filt <- clinical[common_ids, ]

# Check they are aligned
stopifnot(all(colnames(expr_filt) == rownames(clinical_filt)))

dim(expr_filt)
dim(clinical_filt)
```

### SECTION 3: Normalization

```{r}
# Building DESeqDataSet using filtered & matched data
dds <- DESeqDataSetFromMatrix(
  countData = expr_filt,      # <- use expr_filt
  colData   = clinical_filt,  # <- use clinical_filt
  design    = ~ 1             # no specific design yet
)

# Keeping only genes with 10 or more counts
keep <- rowSums(counts(dds)) >= 10
dds  <- dds[keep, ]

# Normalized counts
dds <- estimateSizeFactors(dds)
norm_counts <- counts(dds, normalized = TRUE)

# Variance stabilized transform (for downstream analysis such as clustering)
vsd <- vst(dds, blind = TRUE)
expr_vst <- assay(vsd)

dim(expr_vst)
expr_vst[1:5, 1:5]


```


### Section 4: Create function to convert gene codes to actual gene names

```{r}
get_gene_symbols <- function(ens_ids) {
  # Remove version numbers
  ens_clean <- sub("\\..*", "", ens_ids)
  
  # Map Ensembl IDs → gene symbols
  symbol_map <- mapIds(
    org.Hs.eg.db,
    keys = ens_clean,
    keytype = "ENSEMBL",
    column = "SYMBOL",
    multiVals = "first"
  )
  
  # Replace any NA with original ENSG ID if no symbol found
  symbol_map[is.na(symbol_map)] <- ens_ids[is.na(symbol_map)]
  
  # Return just the values as a plain vector
  unname(symbol_map)
}



```

### SECTION 5: PCA ###
```{r}
expr_vst_t <- t(expr_vst)

# Perform PCA
pca_res <- prcomp(expr_vst_t, center = TRUE, scale. = FALSE)

var_explained <- pca_res$sdev^2 / sum(pca_res$sdev^2)
var_explained_percent <- round(var_explained * 100, 2)

var_explained_percent[1:5]   



```

PCA is useful in RNA-seq expression analysis because gene expression data are high-dimensional and continuous, with thousands of genes varying across samples. PCA reduces this complexity by identifying the major axes of variation that summarize overall biological patterns, such as immune activity, tumor purity, or cell-cycle programs, and helps reveal whether clinical factors (like early vs late cancer stage) naturally separate in the data. However, this same approach does not make sense for the mutation dataset, because mutation matrices are extremely sparse and binary—most genes are unmutated in most patients, producing almost all zeros with no continuous gradients of variation. Without meaningful covariance or continuous structure, PCA cannot extract biologically relevant components from mutation data. In short, PCA works well for continuous gene expression matrices but is not appropriate for sparse 0/1 mutation profiles.

```{r}
# Loadings for PC1
pc1_loadings <- pca_res$rotation[, 1]  
pc1_abs <- abs(pc1_loadings)
top10_genes_pc1 <- names(sort(pc1_abs, decreasing = TRUE))[1:10]
top10_genes_pc1_symbols <- get_gene_symbols(top10_genes_pc1)
top10_genes_pc1_symbols

```  

us



CYP3A4 is a crucial enzyme in the liver, and its expression can significantly impact liver cancer. The gene is involved in the metabolism of more than 50% of prescription drugs, and its polymorphisms can influence how patients metabolize chemotherapeutic agents, affecting treatment outcomes and the risk of adverse effects. Genetic testing for CYP3A4 variants may offer valuable insights for personalized cancer therapy, as these variants can alter enzyme activity and influence the effectiveness of chemotherapy. 

hypothesis: The genes with the most varaince will likley have an impact on cancer



use PCA1-PCAn to do analysis like clustering - then when we want to do analysis we can look at the top genes that make up each pca to see what genes supply the most variance





